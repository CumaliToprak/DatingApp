= Build an app with ASPNET Core and Angular from scratch

== Bölüm 1:Introduction

To learn which version of dotnet sdk installed:
dotnet --info
To learn which versino of dotnet sdk in use:
dotnet --version

*NOT:* Node.js is javascript runtime. it is also package manager we can install package for angular.

To learn which versin of node installed: node --version

npm comes with installing node.js : npm --version

*Postman:* an app to test by sending crud request to our api.

*sqlitebrowser:* https://sqlitebrowser.org/dl/

== Bölüm 2:Building a Walking Skeleton



----
inside desktop:
$ mdkir datingApp
$ cd datingApp
to see help command for dotnet 
$ dotnet -h
to see help command for dotnet new
$ dotnet new -h
to create dotnet webapi project seperate from angular template(we will angular in our project in future using angular provided tool)
$ dotnet new webapi -n DatingApp.API (-n === name)
open the projent in vscode editor
$ code .
Note:if it dosent open inside vscode search on top section path and choose the first option to add vscode to path.
----

*Adding some extension:*

. C# (Powered by OmniSharp)
. C# extensions
. NuGet Package Manager

*Excluding(hiding not get riding of) obj and bin files from the project*

we dont need to see obj and bin files in our project we can exclude them : setting Text Editor -> files -> Exclude section

*To run our project after that:*

----
$ dotnet run
----

*To exclude https url from our project:*

We dont handle security at the beginning of this course for that reason we can remove it: Properties -> launchSettings.json -> DatingApp.API -> applicationUrl 
After that go to startup.cs file and comment 
----
// app.UseHttpsRedirection();
----

command.

*launchSettings.json:* dotnet run yapıldığı zaman bu dosya da okunur.

=== Running the DotNet Core application

in the browser page:


image::..\DatingApp\course-images\img3.png[]
image::..\DatingApp\course-images\img4.png[]

we used ValuesController datas using http reques on the browser.

=== Using DotNet watch

for not to do ctrl+c to updated changes and reload we can use the next command to handle it:  *dotnet watch run*

=== Using production mode

exception mesajlarını browserda kullanıcıdan gizlemek daha basit mesaj vermek için development mode yerine productin mod kullanılır. Bunu değiştirmek için: *properties-> launchSetting.json* 

image::..\DatingApp\course-images\img5.png[]

production olarak değiştirilir.

*Not:* Exception mesajları browsera değil consola log olarak yansır. Ordan exception mesajlarını detaylı olarak görebiliriz.
 

            

== Creating the firs Model and DataContext

we'll use entity fr. code first migration to store data

*create models -> Value*

----
namespace DatingApp.API.models
{
    public class Value
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }
}
----

*create data -> DataContext.cs*

----
using DatingApp.API.Models;
using Microsoft.EntityFrameworkCore;

namespace DatingApp.API.Data
{
    public class DataContext : DbContext //it is derived from Microsoft.EntityFrameworkCore. Need to include the library. 
    {
        public DataContext(DbContextOptions<DataContext> options) : base(options)
        {
        }

        public DbSet<Value> Values { get; set; } // Values represents table name.
    }
}


----

to use DbContext class we should add  *Microsoft.EntityFrameworkCore* library using nuget package manager.

*Finally* we export the class as service, to do that:
in *Startup.cs*

image::..\DatingApp\course-images\img6.png[]
to use sqlite we should add  *Microsoft.EntityFrameworkCore.Sqlite* library using nuget package manager.

*After adding libraries:*

image::..\DatingApp\course-images\img7.png[]

*Not:* By conventions we use title case for C# classes.

*to install dotnet entity framework tool:* via terminal type

=== Creating the Database using Entity Framework migrations

image::..\DatingApp\course-images\img8.png[]
image::..\DatingApp\course-images\img9.png[]

----
dotnet install --global dotnet-ef
dotnet-ef -h
dotnet ef migration -h
----

*after the next command:*
----
dotnet ef migrations add InitialCreate
----
*we get the error:*
----
Your startup project 'DatingApp.API' doesn't reference Microsoft.EntityFrameworkCore.Design. This package is required for the Entity Framework Core Tools to work. Ensure your startup project is correct, install the package, and try again.
----

to solve that we copy the package reference and installed it using nuget package manager: *Microsoft.EntityFrameworkCore.Design*

----
dotnet ef migrations add InitialCreate
----

image::..\DatingApp\course-images\img10.png[]


*the next command create the database:*

image::..\DatingApp\course-images\img11.png[]


*we'll open the datingapp.db using a tool(DB Browser for SQLite):*

image::..\DatingApp\course-images\img12.png[]

=== Retrieving data from the Database

inside Data -> DataContext.cs
----
before: 

  // GET api/values
        [HttpGet]
        public ActionResult<IEnumerable<string>> Get()
        {
            return new string[] { "value1", "value32" };
        }

after:

 public IActionResult GetValues()
        {
            var values = _context.Values.ToList();

            return Ok(values); //http 200 ok respond
        }

----



----
before:


after:

 // GET api/values/5
        [HttpGet("{id}")]
        public IActionResult GetValue(int id)
        {
            var value = _context.Values.FirstOrDefault(x => x.Id === id);

            return Ok(value);
        }


----

*to run project:*
----
dotnet watch run
----


*open postman:*

image::..\DatingApp\course-images\img15.png[]
image::..\DatingApp\course-images\img13.png[]
image::..\DatingApp\course-images\img14.png[]

=== Making our code asynchronous

*inside ValuesController:*

----
        // GET api/values
        [HttpGet]
        public async Task<IActionResult> GetValues()
        {
            var values = await _context.Values.ToListAsync();

            return Ok(values); //http 200 ok respond
        }

        // GET api/values/5
        [HttpGet("{id}")]
        public async Task<IActionResult> GetValue(int id)
        {
            var value = await _context.Values.FirstOrDefaultAsync(x => x.Id === id);

            return Ok(value);
        }
----


=== Creating the Angular application using AngularCLI

*https://cli.angular.io/*

----
inside our project:
npm install -g @angular/cli
ng new DatingApp-SPA
cd DatingApp-SPA
ng serve
----

image::..\DatingApp\course-images\img16.png[]

=== Adding VS Code extensions used in this course

. Angular snippets - john papa
. Angular files
. Angular language service
. Auto rename tag
. Bracket pair colorizer
. Debugger for chrome (we can debug our javascript code but this is really useful when we are in vscode)
. Material icon theme   
. Prettier - Code formatter
. TSLint
. angular2-switcher

=== 17. Making HTTP requests in Angular

Using right click in the src -> app folder create the new component named 'value'.

for automatically created the component references will be added to app.module.ts.

*to making http request in angular we should do next steps:*

image::Desktop\DatingApp\course-images\img17.png[]

*inside app.module.ts:*

image::Desktop\DatingApp\course-images\img18.png[]

*after that inside app.component.html file we call app-value selector to view of value.component.html*

image::Desktop\DatingApp\course-images\img19.png[]


*we should run the project inside two seperate terminal:*
----
ng serve

dotnet watch run
----

*if open browser and click inspect we get next error:*

Access to XMLHttpRequest at 'http://localhost:5000/api/values' from origin 'http://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.

*NOT:* it is probably for angular do not know the domain name api has.

=== Adding CORS support to the API

image::Desktop\DatingApp\course-images\img20.png[]
image::Desktop\DatingApp\course-images\img21.png[]

=> After doing them errors is gone.

image::Desktop\DatingApp\course-images\img22.png[]

=== 17. Displaying data from the API on the html page

image::Desktop\DatingApp\course-images\img23.png[]
image::Desktop\DatingApp\course-images\img24.png[]

=== 18. Adding Bootstrap and Font-Awesome to our Angular app

image::Desktop\DatingApp\course-images\img25.png[]

=== 19. Adding GIT for source control

*in the DatingApp folder:*
----
git init
----

*in the DatingApp.API folder add .gitignore file, add the gitignore following lines:*

----
.vscode
bin
obj
*.db
----

commit the change locally as 'Initial commit' on the left side bar.

*go to the github and create new repository and get the remote address and paste to terminal inside of project directory*

*to push local to remote:*


image::Desktop\DatingApp\course-images\img27.png[]


paste terminal inside your project directory

=== 20. Summary of Section 2

image::Desktop\DatingApp\course-images\img26.png[]

== Security

=== Introduction

image::Desktop\DatingApp\course-images\img28.png[]

=== Storing the passwords in the Database

image::Desktop\DatingApp\course-images\img29.png[]
image::Desktop\DatingApp\course-images\img30.png[]
image::Desktop\DatingApp\course-images\img31.png[]

---

*Hashing+salting* => Çok daha güçlü şifreler oluşturulur. Aynı password için bile çok farklı şifrelemeler oluşturulur. Bunu rasgele randomly oluşan salting sağlar.

---

=== Creating the User model

*inside model director => create User.cs file add the following props:*
----
namespace DatingApp.API.Models
{
    public class User
    {
        public int Id { get; set; } 
        public string Username { get; set; }
        public byte[] PasswordHash { get; set; }
        public byte[] PasswordSalt { get; set; }
    }
}
----

*and the go to DataContext.cs file and update the file:*

----
using DatingApp.API.Models;
using Microsoft.EntityFrameworkCore;

namespace DatingApp.API.Data
{
    public class DataContext : DbContext //it is derived from Microsoft.EntityFrameworkCore. Need to include the library. 
    {
        public DataContext(DbContextOptions<DataContext> options) : base(options)
        {
        }

        public DbSet<Value> Values { get; set; } // Values represents table name.
        
        public DbSet<User> Users { get; set; } //Users represent User table name
    }
}

----


*and then inside terminal:* 

---

dotnet ef migrations add AddedUserEntity

*after that:*

dotnet ef database update

---

*NOT:* If you look at the dbBrowser for sqlite you  can see the user table in there.

=== The repository pattern

image::Desktop\DatingApp\course-images\img32.png[]
image::Desktop\DatingApp\course-images\img33.png[]


=== Creating an Interface for the Repository

*inside Data folder create new interface named IAuthRepository, and then add following line inside it*:

----
using System.Threading.Tasks;
using DatingApp.API.Models;

namespace DatingApp.API.Data
{
    public interface IAuthRepository
    {
         Task<User> Register(User user, string password);
         Task<User> Login (string username, string password);
         Task<bool> UserExists(string username);
    }
}
----

=== Creating the concrete Auth Repository and Register Method

----
using System;
using System.Threading.Tasks;
using DatingApp.API.Models;

namespace DatingApp.API.Data
{
    public class AuthRepository : IAuthRepository
    {
        private readonly DataContext _context;
        public AuthRepository(DataContext context) //to inject DataContext to this class.
        {
            _context = context;
        }
        public Task<User> Login(string username, string password)
        {
            throw new System.NotImplementedException();
        }

        public async Task<User> Register(User user, string password)
        {
            byte[] passwordHash, passwordSalt;

            CreatePasswordHash(password, out passwordHash, out passwordSalt);

            user.PasswordHash = passwordHash;
            user.PasswordSalt = passwordSalt;

            await _context.Users.AddAsync(user);
            await _context.SaveChangesAsync();

            return user;

        }

        private void CreatePasswordHash(string password, out byte[] passwordHash, out byte[] passwordSalt)
        {
            using (var hmac = new System.Security.Cryptography.HMACSHA512())
            {
                passwordSalt = hmac.Key;
                passwordHash = hmac.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password));
            }

        }

        public Task<bool> UserExists(string username)
        {
            throw new System.NotImplementedException();
        }
    }
}
----

image::Desktop\DatingApp\course-images\img34.png[]


=== 7. Creating the Login repository method

image::Desktop\DatingApp\course-images\img35.png[]
image::Desktop\DatingApp\course-images\img36.png[]


=== 8. Registering services in the Startup class

---

Şimdi oluşturduğumuz IAuthRepository ve AuthRepository classlarının application ile haberleşmesi için bunu startup classında service olarak tanımlamalıyız. Bu sayede bu repositoryleri classımıza enjekte etmiş olur.

---

image::Desktop\DatingApp\course-images\img37.png[]

=== 9. Creating the Register method in our Auth Controller

we Create new Controller inside Controllers named AuthController. And then filled the controller.

----
using System.Threading.Tasks;
using DatingApp.API.Data;
using DatingApp.API.Models;
using Microsoft.AspNetCore.Mvc;

namespace DatingApp.API.Controllers
{
    [Route("api/[controller]")]  //means  ->  /api/Auth routes to AuthController
    [ApiController]   //attribute
    public class AuthController : ControllerBase //A base class for an MVC controller without view, we use angular for view implementation
    {
        private readonly AuthRepository _repo;
        public AuthController(AuthRepository repo)
        {
            _repo = repo;
        }


        [HttpPost("register")]
        //we will refactor parameter type later on. Because the parameter will come in json format.
        public async Task<IActionResult> Register(string username, string password) 
        {
            username = username.ToLower();


            if(await _repo.UserExists(username)) 
                return BadRequest("Username already exists"); // to use this method we have to implemet controllerbase class to this controller.
            //for Register method get user object. we create user object.
            var userToCreate = new User{
                Username = username
            };

            var createdUser = await _repo.Register(userToCreate, password);
            
            return StatusCode(201); //we will refactor this later on.

        }    


    }
}
----

=== 10. Using DTOs (Data Transfer Objects)

inside DatingApp.API create  Dtos folder and then inside it create UserForRegisterDto:

----
namespace DatingApp.API.Dtos
{
    public class UserForRegisterDto
    {
        public string Username { get; set; }
        public string Password { get; set; }
    }
}
----

Bu proplar register için gelen requestin değerlerini tutucak.

Debug yaparsak:

image::Desktop\DatingApp\course-images\img39.png[]


=== Token Authentication

image::Desktop\DatingApp\course-images\img40.png[]
image::Desktop\DatingApp\course-images\img41.png[]
image::Desktop\DatingApp\course-images\img42.png[]
image::Desktop\DatingApp\course-images\img43.png[]

=== Creating the Login method in the API

*By NuGet package manager, Install:* 

. "Microsoft.IdentityModel.Tokens" -> latest stabel version
. "System.IdentityModel.Tokens.Jwt"

inside AuthController -> create the login method.

----
 [HttpPost("login")]

        public async Task<IActionResult> Login(UserForLoginDto userForLoginDto)
        {
            var userFromRepo = await _repo.Login(userForLoginDto.Username.ToLower(), userForLoginDto.Password);

            if (userFromRepo == null)  //ıf the user dosent exist in db it return null.
                return Unauthorized();


            var claims = new[] {
                new Claim(ClaimTypes.NameIdentifier, userFromRepo.Id.ToString()),  //token string old. ToString() yaptık.
                new Claim(ClaimTypes.Name, userFromRepo.Username)
            };

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config.GetSection("AppSettings:Token").Value)); //we store the key in the AppSetting.Json file
                                                                                                                    //.Value is used to get the value of this token
            //encrypting the key using hashing algorithm                                                                  
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha512Signature);

            var tokenDescriptor = new SecurityTokenDescriptor{
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.Now.AddDays(1), //expire date is a day. It is just for training course purposes.
                SigningCredentials = creds
            };

            var tokenHandler = new JwtSecurityTokenHandler();

            var token = tokenHandler.CreateToken(tokenDescriptor);

            return Ok(new {
                token = tokenHandler.WriteToken(token)
            });
        }
----


*add the token key inside AppSettings.json file *

----
{
  "AppSettings":{
    "Token": "super secret key" 
  },
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=datingapp.db"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}




----

image::Desktop\DatingApp\course-images\img44.png[]   


=== Using the Authentication middleware

Bu katmanla valueController Authenticationdan haberdar olacak ve herhangi bir veri isteğinden veya requestte dtabase gidip kimlik doğrulama yapmayacak.

*Öncelikle bazı paketleri indirmemiz gerekir NuGet package managerdan:*

. Microsoft.AspNetCore.Authentication.JwtBearer -> Version="3.1.3"

image::Desktop\DatingApp\course-images\img45.png[]

[Authorize] atributun bu yetkilendirmeyi anlaması için startup.cs classında bunu servis olarak eklememiz gereekir.(We should add authentication as a service)(We have to say AspNet core what type authentication we use)

image::Desktop\DatingApp\course-images\img47.png[]
image::Desktop\DatingApp\course-images\img46.png[]

*Open postman and test the changes:*

to get single value:

image::Desktop\DatingApp\course-images\img48.png[]

to get all the values:

image::Desktop\DatingApp\course-images\img49.png[]

*to get all the values we must be authorized. to do that we shoul login and then get the token and past the token in the header section of the get request:*

image::Desktop\DatingApp\course-images\img52.png[]

image::Desktop\DatingApp\course-images\img50.png[]
image::Desktop\DatingApp\course-images\img51.png[]

=== Safe storage of secrets

appsettings.json da tokenla alakalı hassas bilgiler olduğu için bu dosyayı github gibi halka açık bbir platforma göndermek iyi değildir. Bu yüzden bu dosyayı untracked yapmalıyız.

image::Desktop\DatingApp\course-images\img53.png[]

----
$ git rm appsettings.json --cached
----

Aslında tokena ait key'i production modda appsettings.json da değil bazı işlemlerle başka bir yerde gizleyerek tutarız. Buna ilerleyen bölümlerde bakıcaz.

 
== Bölüm 4:Client side login and register

=== Introduction

image::Desktop\DatingApp\course-images\img54.png[]

=== Creating the Navigation and Login form

https://getbootstrap.com/docs/4.1/examples/jumbotron/?#

. inspect -> copy the element
. create a new component named nav
. inside the html page of nav paste the element info    

*NOT:* Bu modülün açıklamalarını angularda editör üzerinde yaptık. Kod satırları ile anlayabilirim.


== Bölüm 5:Error Handling

=== Handling exceptions in the API

*500 internal error:* server errordur. angular tarafıyla  ilgisi yoktur. api tarafından oluşur.

=== Setting up the Global exception handler in the API

*NOT:* _Global exception Handling sayesinde try-catchle blokları ile biz uğraşmadan ASP .NET CORE bizim yerimize hataları handle eder._

AuthController classının login metodunda tanımladığımız try-catch bloklarını kaldırırız öncelikle.

image::Desktop\DatingApp\course-images\img55.png[]
image::Desktop\DatingApp\course-images\img56.png[]

Global exception handlera cause header eklemek için ekstra bir metoda ihtiyacımız var. Bu yüzden Helper folderı oluşturup Extensions classını ve AddApplicationError metodlarını static olarak oluştururuz.

----
using Microsoft.AspNetCore.Http;

namespace DatingApp.API.Helpers
{
    public static class Extensions //Extension metodları içerecek class. Nesne örneğini oluşturmamak için static olarak tanımladık.
    {
        public static void AddApplicationError(this HttpResponse response, string message){ //to override http response : this HttpResponse response 
            //reponse(global exception handler tarafından gönderilen response) a yeni header eklemek istediğimiz için:
            response.Headers.Add("Application-Error", message);
            response.Headers.Add("Access-Control-Expose-Headers","Application-Error");
            response.Headers.Add("Access-Control-Allow-Origin","*"); //*: is a wildcard(joker) = yani tüm originlere izin ver demek.

        }
    }
}
----

image::Desktop\DatingApp\course-images\img57.png[]
----
$ dotnet run
----

*Postmande istek yapalım:*

image::Desktop\DatingApp\course-images\img58.png[]
image::Desktop\DatingApp\course-images\img59.png[]


*NOT:* Server tarafından gönderilen bu cause headerler sayesinde kullanıcı hatayla ilgili bilgilendirilmiş olunur.

=== 4. Handling errors in Angular

. *services klasörüne error.interceptor.ts adında boş bir file oluşturup aşağıdaki gibi şablonu oluştururuz.*

Bu class yardımı ile apidan gelen hataları istediğimiz gibi filtreler angular tarafına, browser tarafına istediğimiz yalınlıkla ve uygunlukta göndeririz.

----
import {
  HttpErrorResponse,
  HttpEvent,
  HttpHandler,
  HttpInterceptor,
  HttpRequest,
  HTTP_INTERCEPTORS,
} from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

//Bu bir servis classı olmamasına rağmen servis folderının içerisinde yazmamızın sebebi bu koyacak doğru yerin burası olması.

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  //HttpInterceptor Api tarafından gelen hataları tanıyacak ve yakalayacak
  intercept(
    req: HttpRequest<any>,
    next: HttpHandler
  ): Observable<HttpEvent<any>> {
    //throw new Error('Method not implemented.'); 'ı sildik.
    return next.handle(req).pipe(
      catchError((error) => {
        if (error.status === 401) {
          return throwError(error.statusText); //angular componente fırlatılır.
        }
        if (error instanceof HttpErrorResponse) {
          //this condition takes care of 500 error(internal error)
          const applicationError = error.headers.get('Application-Error'); //Application-Error isimli headera sahip internal server errorı çeker.
          if (applicationError) {
            return throwError(applicationError);
          }

          const serverError = error.error;
          let modalStateErrors = ''; //email, password dosent provide requirements örn: parola 3 haneden buyuk olmalı.
          if (serverError.errors && typeof serverError.errors === 'object') {
            //serverError.errors obje ise loop ile içerisini gezip elemanları kullancaz
            for (const key in serverError.errors) {
              if (serverError.errors[key]) {
                modalStateErrors += serverError.errors[key] + '\n';
              }
            }
          }
          return throwError(modalStateErrors || serverError || 'server error'); //modalStateError boş ise serverErroru gönderir. burda serverError===error.error 'a eşittir. o da 'username already exists' 'e denk gelir diyebiliriz.
          //Hiçbiri değilse 'server error' mesajlı exception atar. Sonradan gelip bu errorun ne olduğunu anlamaya çalışırız.
          //serverError=error.error -> username already exists. : Sadece string mesaj olan error.
        }
      })
    );
  }
}

export const ErrorInterceptorProvider = {
  provide: HTTP_INTERCEPTORS,
  useClass: ErrorInterceptor,
  multi: true, // HTTP_INTERCEPTORS can have many interceptor.
};

----

image::Desktop\DatingApp\course-images\img60.png[]


== Adding 3rd party components to our app

=== Wrapping 3rd party libraries as an Angular service

*_alertifyjs_:* Kullanıcıya notification vermek için kullanılır.

.go to the client app(DatingApp-SPA) inside terminal and run the next command.

----
$ npm install alertifyjs
----


.alertifyjs in referanslarını style.css classına global olarak ekleriz.


image::Desktop\DatingApp\course-images\img61.png[]

.alertifyı diğer componentlerin ortak bir noktadan kullanabilmeleri için servis olarak oluşturuyoruz.

----
import { Injectable } from '@angular/core';
import * as alertify from 'alertifyjs';

@Injectable({
  providedIn: 'root'
})
export class AlertifyService {

constructor() { }

  confirm(message: string, okCallBack: () => any) { //dönüş tipi herhangi bir tip olabileck fonksiyonu parametre olarak böyle tanımlarız.
    alertify.confirm(message, (e:any)=>{
      if(e){
        okCallBack();
      }else{}
    });
  }

  success(message:string){
    alertify.success(message);
  }

  
  error(message:string){
    alertify.error(message);
  }

  
  warning(message:string){
    alertify.warning(message);
  }

  
  message(message:string){
    alertify.message(message);
  }
}
----

*bu servisi nav ve register componentin kullanabilmesi için bu servisleri enjekte ederler.*

image::Desktop\DatingApp\course-images\img62.png[]

=== Using the Angular JWT library to improve token handling

. type google 'auth0 angular jwt'
. https://github.com/auth0/angular2-jwt
. And then go back terminal window and run 'npm install @auth0/angular-jwt' command to install this package to SPA 
----
$ npm install @auth0/angular-jwt
----

Kullanıcının login olup olmadığını kontrol eden metodu daha önce nav componentte yazmıştık.

*before:*

----

  loggedIn(){
    const token = localStorage.getItem('token'); //local storagedan keyi token olan tokenı getirir.
    return !!token; // if token empty ise false, dolu ise true döndürür.
  }
----

Ama bu metodu burada yazmak mantıklı değil çünkü bu metodu diğer componentler de yeri geldiği zaman kullanacak. Bu metodu kullanacak componentlerin nav componenti import etmeleri gerekecek. Componentlerin görevi bu değildir. Bu servislerin görevidir. Daha önce oluşturduğumuz authservice servisine bu metodu oluştururuz. 

*after:*

image::Desktop\DatingApp\course-images\img63.png[]


Bu servisi nav componente daha inject etmiştik. metoda bağlayalım

----
  loggedIn(){
    // const token = localStorage.getItem('token'); //local storagedan keyi token olan tokenı getirir.
    // return !!token; // if token empty ise false, dolu ise true döndürür.
    return this.authService.loggedIn();
  }

----

=== Using the Angular JWT library to decode tokens

---

Bu bölümde jwt kütüphanesi yardımıyla elde ettiğimiz tokenı decode edip kullanıcı adını çekip sağ üstte login olduktan sonraa *welcome kullanıcıAdı* şeklinde görüntüleyeceğiz.

---

image::Desktop\DatingApp\course-images\img64.png[]
image::Desktop\DatingApp\course-images\img65.png[]
image::Desktop\DatingApp\course-images\img66.png[]

---

Sayfayı yenilediğimiz zaman kullanıcı adı görülmeyecek çünkü bu kullanıcı adını sadece login olduğumuz zaman çekiyoduk. Bu yüzden bunu merkezi bir yerde de yapmalıyız. Her app load olduğu zaman kullanıcı adını çekmeli local storagedan. Bu yer *app component olmalı*

---

*Before*

image::Desktop\DatingApp\course-images\img67.png[]

*After*

inside app.component.ts:

----
import { Component, OnInit } from '@angular/core';
import { JwtHelperService } from '@auth0/angular-jwt';
import { AuthService } from './_services/auth.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})

//Bu class angular cli tarafından oluşturulduğundan şablon tamamlanmamıştır. oninit, constructor ve gerekli kütüphaneleri biz ekleyeceğiz. tokendan username'i çekmek için.

export class AppComponent implements OnInit {
  jwtHelper = new JwtHelperService();
  constructor(private authService: AuthService) {
    
  }
  ngOnInit(){
    const token = localStorage.getItem('token');
    if(token){
      this.authService.decodedToken = this.jwtHelper.decodeToken(token);
    }
    
  }

}

----

---

app.component.ts' de yapılan değişikliklerden sonra artık sayfayı reload yaptığımız zaman da hata almadık.

---

=== Adding Ngx Bootstrap to power our Bootstrap components

 . https://valor-software.com/ngx-bootstrap/#/

*NOT:* angularjs ile çalıştığımız zaman Ngx Bootstrap ile elde edeceğimiz fonksiyonaliteler orda default olarak mevcut olur. Fakat angularjs jquerye bağımlıdır. Angular ile çalışırken jquery ile çalışmak mantıklı gelmiyor. bu yüzden kurs boyunca pure angular gidicez. Burda Ngx Bootsrap işimizi oldukça iyi görür.

----
$ npm install ngx-bootstrap --save
----

*NOT:* npm install kullandığımız için app.module.ts import bolumune BrowserAnimationsModule' u eklememiz gerektiğini söyledi Neil. Ekledik.

image::Desktop\DatingApp\course-images\img68.png[]
image::Desktop\DatingApp\course-images\img69.png[]
image::Desktop\DatingApp\course-images\img70.png[]

=== Bringing some color to our app with a theme from Bootswatch

 . https://bootswatch.com/ : Free themes for Bootstrap

 . install the same version of the bootstrap
 
----
 $ npm install bootswatch@version
----

.Bootswatch kütüphanesini hemen bootsrap kütüphanesinn altına koyarız. Aslında suan bootstrap kütüphanesini kaldırabiliriz de.
image::Desktop\DatingApp\course-images\img71.png[]

.primary yapmamızın sebebi dark olursa turuncuyu mora çeviriyordu.
image::Desktop\DatingApp\course-images\img72.png[]

== Routing in Angular

===  Setting up routing in Angular

Bu bölümde oluşturduğumuz yeni componentler arasında routing işlemini göreceğiz.

öncelikle app folder içerisinde routes.ts file oluşturup aşağıdaki dolduralım.

.Bunu kullanabilmek için app.module.ts'e import etmemiz gerekir.

image::Desktop\DatingApp\course-images\img73.png[]

----
RouterModule.forRoot(appRoutes)
----

import kısmına yukardaki satırı ekleyip ilgili file'da yukarıya import ederiz .

=== Protecting our routes with a route guard

---

Yetkisi olmayan kullanıcının url' i değiştirerek farklı routelara girmesini engellemek için *route guard* kullanılır.

---

. app -> _guard folder oluşturulur.
. cd src/app/_guards
. angular cli ile aşağıdaki komut çalıştırılır.
. choose canActivate interface

----
$ ng g guard auth --skipTests
----

--skipTests : test istemiyoruz

---

Yukarıdaki çalıştırılan komutla auth.guard.ts oluşturulmuş olur. Default şablonda çok fazla şey vardır. Biz kendi ihtiyaçlarımıza göre şablonu düzelltik.

---

*auth.guard.ts :*


----
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { AlertifyService } from '../_services/alertify.service';
import { AuthService } from '../_services/auth.service';

@Injectable({
  providedIn: 'root',
})
export class AuthGuard implements CanActivate {
  constructor(
    private authService: AuthService,
    private router: Router,
    private alertify: AlertifyService
  ) {}

  //Sadece true olduğunda bu route'u aktif et.
  canActivate(): boolean {
    if(this.authService.loggedIn()){
      return true;
    }

    this.alertify.error('You shall not pass!!!');
    this.router.navigate(['/home']);
    return false;
  }
}

----

---

Şimdi routes.ts de oluşturduğumuz path-component çiftlerinden hangisi korumak istiyosak canActivate[AuthGuard] ile koruruz.

---

*routes.ts:*

----
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { ListsComponent } from './lists/lists.component';
import { MemberListComponent } from './member-list/member-list.component';
import { MessagesComponent } from './messages/messages.component';
import { AuthGuard } from './_guards/auth.guard';

export const appRoutes : Routes = [
    {path: 'home', component: HomeComponent}, //path-component cifti yazılır. Order is important. Wildcard başta olsa hep aynı domaine gider mesela.
    {path: 'members', component: MemberListComponent, canActivate: [AuthGuard]},
    {path: 'messages', component: MessagesComponent},
    {path: 'lists', component: ListsComponent},
    {path: '**', redirectTo: 'home', pathMatch:'full'}, //joker: yukarıdakilerden herhangi biri ile eşleşmesse buraya yönledirilir. Angular first match mantığına göre çalışır. Hangi pathle eşleşirse oraya gider ilk.
];


----

===  Protecting multiple routes with a single route guard using dummy routes


Buradaki amaç her ayrı route için *canActivate: [AuthGuard]* kullanmak yerine bunlar için temsili bir parent root oluşturulup bunları merkezi bir yerden kontrol etmektir.


== Extending the API

=== Extending the User Model

*User.cs:* 

----
using System;
using System.Collections.Generic;

namespace DatingApp.API.Models
{
    public class User
    {
        public int Id { get; set; } 
        public string Username { get; set; }
        public byte[] PasswordHash { get; set; }
        public byte[] PasswordSalt { get; set; }
        public string Gender { get; set; }
        public DateTime DateOfBirth { get; set; }
        public string KnownAs { get; set; }
        public DateTime Created { get; set; }
        public DateTime LastActive { get; set; }
        public string Introduction { get; set; }
        public string LookingFor { get; set; }
        public string Interests { get; set; }
        public string City { get; set; }
        public string Country { get; set; }
        public ICollection<Photo> Photos { get; set; }
    }
}
----

*Newly created Photo.cs:* 

----
using System;

namespace DatingApp.API.Models
{
    public class Photo
    {
        public int Id { get; set; } 
        public string Url { get; set; }
        public string Description { get; set; }
        public DateTime DateAdded { get; set; }
        public bool IsMain { get; set; }
    }
}
----

image::Desktop\DatingApp\course-images\img74.png[]

*NOT:* Dbset'e yeni bir table ekledikten sonra yeni bir migration oluşturacağımız zaman projenin çalışmasını durdurmamız gerekir. Çünkü entity framework or dotnet ef cli projeyi build edecek.

----

$ dotnet ef migrations add ExtendedUserClass

----

Yeni migration classları migration foldera eklenir.


=== Exploring Entity Framework Migrations

image::Desktop\DatingApp\course-images\img75.png[]

Bunu manuel olarak da değiştiremeyiz.

*Bu migrationı database update edelim:*

----
$ dotnet ef database update
----

*Bu adımdan sonra bu son migrationı silemeyiz:*

----
$ dotnet ef migrations remove
----

*Komudu hata verir.*

---

The migration '20200926131158_ExtendedUser' has already been applied to the database. Revert it and try again. If the migration has been applied to other databases, consider reverting its changes using a new migration.

---

*Eski haline alma gibi işlemi sqlite izin vermiyor. Bu yüzden database'i drop edip recreate ederiz.*


----
$ dotnet ef database drop
----

Bu işlem migrationslara dokunmaz. Aynı şekilde kalır.

*Databaseden drop ettikten sonra şimdi last migrationı remove edebiliriz.*

----
$ dotnet ef migrations remove
----


=== Entity Framework Relationships

Entity Frameworke user ile photo arassındaki ilişkiyi manuel olarak söylememiz gerekicek.


image::Desktop\DatingApp\course-images\img77.png[]


----
$ dotnet ef migrations add ExtendendUserClass
----

image::Desktop\DatingApp\course-images\img76.png[]
    
*Şimdi user silindiği zaman o usera ait fotolarda ilişkili olarak silinmiş olacak.*


=== Seeding Data to the Database 

https://www.json-generator.com/

Bu siteden json formatta randomly generated data elde edebiliriz. kullandığımız script kursta var. Şuan için NEİL'in oluşturduğu kullanıcıları kullanıcaz.

Data klasöründe -> UserSeedData.json file oluşturup içerisine json formatta oluşturulmuş kullanıcı datalarını ekleriz.

===  Seeding Data to the Database Part 2

json formattaki dataları user modelle ilişkilendirmek için Seed.cs classını oluşturduk.

----
using System.Collections.Generic;
using System.Linq;
using DatingApp.API.Models;
using Newtonsoft.Json;

namespace DatingApp.API.Data
{
    public class Seed
    {
        public static void SeedUsers(DataContext context)
        {
            if (!context.Users.Any()) //Hiç kullanıcı var mı?
            { //to use Any() method import using.linq
                var userData = System.IO.File.ReadAllText("Data/UserSeedData.json");
                var users = JsonConvert.DeserializeObject<List<User>>(userData);  //to user JsonConvert import Newtonsoft.Json
                foreach (var user in users)
                {   
                    byte[]  passwordHash, passwordSalt;
                    CreatePasswordHash("password",out passwordHash,out passwordSalt); //passwordların hepsinin değeri password old. direkt yazdık.

                    user.PasswordHash = passwordHash;
                    user.PasswordSalt = passwordSalt;
                    user.Username = user.Username.ToLower();
                    context.Users.Add(user);
                }
                    context.SaveChanges(); //asyn olarak yapmaya gerek yok çünkü program çalışmaya başladığında ilk olarak burası çalışcak.
            }

        }


        //Bu metodu AuthRepository classından getirdik.
        //Bu metodu sadece burda kullanacağımız için AuthRepositoryde public yapmadık.
        private static void CreatePasswordHash(string password, out byte[] passwordHash, out byte[] passwordSalt)
        {
            using (var hmac = new System.Security.Cryptography.HMACSHA512())
            {
                passwordSalt = hmac.Key;
                passwordHash = hmac.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password));
            }

        }
    }
}
----

bunu program.cs classına bağladık.

----
using System;
using DatingApp.API.Data;
using Microsoft.AspNetCore.Hosting;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace DatingApp.API
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var host = CreateHostBuilder(args).Build();
            //DataContext'i parametre olarak gönderdikten sonra ondan kurtulmak istiyoruz. O yüzden using kullanırız.
            using(var scope = host.Services.CreateScope()){ // to use CreateScope() method import Microsoft.Extensions.DependencyInjection;
                var services = scope.ServiceProvider;
                //Bu metod main metod olduğundan ve ilk çalıştırılıcak metod olduğundan burada bir exception handling middleware yok bu yüzden try-catch kullanırız.
                try
                {
                    var context = services.GetRequiredService<DataContext>(); //DataContext'i parametre olarak göndereceğimiz için alırız.
                    context.Database.Migrate();// bu komut yardımı ile her dotnet run/watch run yaptığımızda databasei kontrol edip update 
                    //edilmemiş migrations varsa update eder. Bizim ayrıca dotnet ef database update yapmamıza gerek yok artık.
                    Seed.SeedUsers(context);
                } 
                catch (Exception ex)
                {
                    var logger = services.GetRequiredService<ILogger<Program>>();
                    logger.LogError(ex, "An error occured during migration");   
                }
            }

            host.Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
    }
}

----

=== Creating a new repository for our API

*Öncelikle delete, add, save , get user metodları için interface ve class repository pattern oluşturduk.*

*IDatingRepositor:*

----
using System.Threading.Tasks;
using DatingApp.API.Models;

namespace DatingApp.API.Data
{
    public interface IAuthRepository
    {
         Task<User> Register(User user, string password);
         Task<User> Login (string username, string password);
         Task<bool> UserExists(string username);
    }
}
----

*DatingRepository:*

----
using System.Collections.Generic;
using System.Threading.Tasks;
using DatingApp.API.Models;
using Microsoft.EntityFrameworkCore;

namespace DatingApp.API.Data
{
    public class DatingRepository : IDatingRepository
    {
        private readonly DataContext _context;
        public DatingRepository(DataContext context)
        {
            _context = context;
        }
        public void Add<T>(T entity) where T : class
        {
            _context.Add(entity); //şuan için asyn yapmaya gerek yok çünkü biz update database yapana kadar bellekte(contexte) bekleyecek.
        }

        public void Delete<T>(T entity) where T : class
        {
            _context.Remove(entity);
        }

        public async Task<User> GetUser(int id)
        {
            //to use Include import : using Microsoft.EntityFrameworkCore;
            var user = await _context.Users.Include(p => p.Photos).FirstOrDefaultAsync(u => u.Id == id);  //photos navigation property olduğu için include metodunu kullandık.

            return user;
        }

        public async Task<IEnumerable<User>> GetUsers()
        {
            var users = await _context.Users.Include(p => p.Photos).ToListAsync();

            return users;
        }

        public async Task<bool> SaveAll()
        {
            return await _context.SaveChangesAsync() > 0; //Eğer databaseden dönen kayıt sayımız sıfrdan büyükse true , değilse false döner.
        }
    }
}
----

Bu clası application da kullanabilmek için startup.cs de servis olarak tanımlamalıyız.

----
services.AddScoped<IDatingRepository,DatingRepository>();
----
*_Bir sonraki kısımda controller tanımlayıp bu concrete metod yardımıyla çektiğimiz verileri clienta verceğiz._*

=== Creating the Users Controller

https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.1&tabs=visual-studio#newtonsoftjson-jsonnet-support

Daha önceleri json responları veyahut dotnet objelerini json objelere çevirmek için Newtonsoft third part software kullanılıyordu. dotnet 3.0 surumunden sonra microsoft System.Text.json ı tanıttı. Fakat şuan bu paket henüz hazır değil ve bizim kullandığımız bazı özellikleri içermiyor. Şimdi burada amacımız applicationı newtonsoft u kullanmak için ayarlamak.

*NuGet package manager dan :*

---

Microsoft.AspNetCore.Mvc.NewtonsoftJson

---

paketini indiririz.

* startup.cs classına gidip*

before:

image::Desktop\DatingApp\course-images\img78.png[]

after:

----
$  services.AddControllers().AddNewtonsoftJson(); 
----

*Şimdi System.Text.Json yerine Newtonsoftu kullanıyor gibi davranacak.*

*Şimdi UsersController.cs classını controller klasörü içerisinde oluşturup içersini ve şablonunu aşağıdaki gibi doldururuz*

----
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using DatingApp.API.Data;
using System.Threading.Tasks;

namespace DatingApp.API.Controllers
{
    // Bu metodlara, verilere ulaşacak kişiler yetkiye sahip olmalı
    [Authorize] //to use import: Microsoft.AspNetCore.Authorization;
    [Route("api/[Controller]")] //Bu spesicif controllera ulaşmak için bu yapıyı kullanırız. bu route bizi : api/users'a yönlendirir.
    [ApiController]
    public class UsersController : ControllerBase
    {
        private readonly IDatingRepository _repo;
        public UsersController(IDatingRepository repo) //Burda concrete class reposunu değil interface repoyu çağırıyoruz. Dikkat!
        {
            _repo = repo;
        }

        [HttpGet] //when request to 'localhost:5000/api/Users bu metod çalışır.
        public async Task<IActionResult> GetUsers(){
            var users = await _repo.GetUsers();

            return Ok(users);
        }

        [HttpGet("{id}")]
        public async Task<IActionResult> GetUser(int id){
            var user = await _repo.GetUser(id);
            return Ok(user);
        }



    }
}
----

*Her zaman client tarafa geçmeden api'yı postman ile test etmeliyiz. Bunun için login olmamız lazım ve bu tokenı headır kısma ekleyip '_localhost:5000/api/users_'
adresine get request yaparız*


*Bunu yaptığımızda hata alırız. postmande bu hatayı görmemiş olsak da terminale gittiğimizde bu hatayı görebiliriz.*

*Hata:* self referencing loop detected for property user bla bla bla

https://stackoverflow.com/questions/7397207/json-net-error-self-referencing-loop-detected-for-type

*Bu hatanın sebebi* user classın içerisinde photos için navigation property var photoya gidince de userı gösteren pointer var, server bu response'u serialize etmek isterken bu döngüyü görür ver der ki this self referencig loop galiba. xd bu bizim problem değil bu yüzden servera biz ne yaptığımızı biliyoz bize hata verme diyeceğiz. Mvc'ye bu hatayı ignore et diyeceğiz de diyebiliriz kısaca.

-> startup.cs'de şunu ekleriz.

----
 services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(options =>
                {
                    options.TokenValidationParameters = new TokenValidationParameters
                    {
                        ValidateIssuerSigningKey = true, // to check our key is valid.
                        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8 //SymmetricSecurityKey wants the key as a byte array. for that reaseos we converted.
                            .GetBytes(Configuration.GetSection("AppSettings:Token").Value)),
                        ValidateIssuer = false, //our Issuer localhost
                        ValidateAudience = false  //our Audience localhost as well.
                    };
                });
                
----

=== Shaping the data to return with DTOs

User bilgileri ile beraber passwordHash ve passwordSalt da gidiyor. Biz bunu istemiyoruz. Bunu da DTO sayesinde sağlayacağız.

*UserForListDto.cs ve UserForDetailedDto.cs classlarını oluştururuz*

*UserForListDto.cs:*

----
using System;

namespace DatingApp.API.Dtos
{
    public class UserForListDto
    {
        public int Id { get; set; }
        public string Username { get; set; }
        public string Gender { get; set; }
        public int Age { get; set; } //Birthdate yerine değiştirdik bunu.
        public string KnownAs { get; set; }
        public DateTime Created { get; set; }
        public DateTime LastActive { get; set; }
        public string City { get; set; }
        public string Country { get; set; }
        public string PhotoUrl { get; set; } //ekstradan bunu ekledik
    }
}
----
 
*UserForDetailedDto.cs:*

----
using System;
using System.Collections.Generic;
using DatingApp.API.Models;

namespace DatingApp.API.Dtos
{
    public class UserForDetailedDto
    {
        public int Id { get; set; }
        public string Username { get; set; }
        public string Gender { get; set; }
        public int Age { get; set; }
        public string KnownAs { get; set; }
        public DateTime Created { get; set; }
        public DateTime LastActive { get; set; }
        public string Introduction { get; set; }
        public string LookingFor { get; set; }
        public string Interests { get; set; }
        public string City { get; set; }
        public string Country { get; set; }
        public string PhotoUrl { get; set; }
        public ICollection<Photo> Photos { get; set; }
    }
}
----


Kullanıcıları çekmek için istek geldiği zaman user classındaki propertylere ait verileri değil dtolardaki proplara göre verileri göndermek istiyoruz. Bunu controllerda uzunca kod yazarak manuel olarak yapabilriz. Fakat bu çok yorucu olur. bunun bizim yerimize yapacak bir tool var.

=== Using AutoMapper Part 1

Bu entitylerimizi(models) Dto'larla eşler.

. AutoMapper.Extensions.Microsoft.DependencyInjection nuget package managerdan indirilir.

. Startup.cs classına gidip AutoMapper ı servis olarak kaydederiz. Böyle onu applicationun her tarafına inject edebiliriz.

. Sonra UsersControllerda mapperı servis olarak inject ederiz.

. User controllerda getUser/s metodları yeniden mapperla modifiye ederiz.

. Helper klasöründe AutoMapperProfiles.cs classı oluşturulur. bu classın amacı tüm mapped class ve dtoları burda eklemek ve AutoMapperın işlevini yapması için bu gerekli.

. Bundan sonra user classındaki bir property isminin aynısı esleştirilmis dto'da da varsa bunu anlar ve buna göre davranır.(akkıllı bir şey xd)

. Değişiklikleri görmek için postmanda denemek istersek hata alırız. Çünkü ctrl+c yapıp kestrel servisi tekrar başlatmalıyız. Yoksa hata alırız.

*Not:* tüm userlar için postmanla istekte bulunduğumuz zaman problem yok tum userlar istediğimiz şekilde UserForListsDto'ya uygun olara gelir. fakat individual user icin requestte bir problem var. Tum fotoları da cektiğimiz için ve photo classının icinde user referansı(full user object) oldugundan tum user bilgilerini de objenin icersinde gönderir. Biz bunu istemiyoruz. Bir sonraki partta bu konuyu handle edeceğiz.


Bunun için PhotosForDetailedDto.cs oluştururuz. 

----
using System;

namespace DatingApp.API.Dtos
{
    public class PhotosForDetailedDto
    {
        public int Id { get; set; }
        public string Url { get; set; }
        public string Description { get; set; }
        public DateTime DateAdded { get; set; }
        public bool IsMain { get; set; }
    }
}
----

*UserForDetailedDto.cs de asagıdaki değişikliiği yaparız.*

----
public ICollection<PhotosForDetailedDto> Photos { get; set; }
----


*Bu mapping işlemini AutoMapperProfile.cs e ekleriz.*

----
CreateMap<Photo, PhotosForDetailedDto>();
----


user/users requestlerinde gönderilen photolara url eklemek ve age propertyi ayarlamak için de AutoMapper'a gerekli kodlar eklenir.

----
 CreateMap<User, UserForListDto>()
            .ForMember(dest => dest.PhotoUrl, opt =>
                opt.MapFrom(src => src.Photos.FirstOrDefault(p => p.IsMain).Url))
            .ForMember(dest => dest.Age, opt => opt.MapFrom(src => src.DateOfBirth.CalculateAge()));
            CreateMap<User, UserForDetailedDto>()
            .ForMember(dest => dest.PhotoUrl, opt =>
                opt.MapFrom(src => src.Photos.FirstOrDefault(p => p.IsMain).Url))
            .ForMember(dest => dest.Age, opt => opt.MapFrom(src => src.DateOfBirth.CalculateAge()));
----

== Building a great looking User Interface (Legacy)

=== Introduction


image::Desktop\DatingApp\course-images\img79.png[]


=== Introduction to Interfaces in Typescript

image::Desktop\DatingApp\course-images\img80.png[]

=== Adding Interfaces to our Typescript code



