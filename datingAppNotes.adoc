= Build an app with ASPNET Core and Angular from scratch

== Bölüm 1:Introduction

To learn which version of dotnet sdk installed:
dotnet --info
To learn which versino of dotnet sdk in use:
dotnet --version

*NOT:* Node.js is javascript runtime. it is also package manager we can install package for angular.

To learn which versin of node installed: node --version

npm comes with installing node.js : npm --version

*Postman:* an app to test by sending crud request to our api.

*sqlitebrowser:* https://sqlitebrowser.org/dl/

== Bölüm 2:Building a Walking Skeleton



----
inside desktop:
$ mdkir datingApp
$ cd datingApp
to see help command for dotnet 
$ dotnet -h
to see help command for dotnet new
$ dotnet new -h
to create dotnet webapi project seperate from angular template(we will angular in our project in future using angular provided tool)
$ dotnet new webapi -n DatingApp.API (-n === name)
open the projent in vscode editor
$ code .
Note:if it dosent open inside vscode search on top section path and choose the first option to add vscode to path.
----

*Adding some extension:*

. C# (Powered by OmniSharp)
. C# extensions
. NuGet Package Manager

*Excluding(hiding not get riding of) obj and bin files from the project*

we dont need to see obj and bin files in our project we can exclude them : setting Text Editor -> files -> Exclude section

*To run our project after that:*

----
$ dotnet run
----

*To exclude https url from our project:*

We dont handle security at the beginning of this course for that reason we can remove it: Properties -> launchSettings.json -> DatingApp.API -> applicationUrl 
After that go to startup.cs file and comment 
----
// app.UseHttpsRedirection();
----

command.

*launchSettings.json:* dotnet run yapıldığı zaman bu dosya da okunur.

=== Running the DotNet Core application

in the browser page:


image::..\DatingApp\course-images\img3.png[]
image::..\DatingApp\course-images\img4.png[]

we used ValuesController datas using http reques on the browser.

=== Using DotNet watch

for not to do ctrl+c to updated changes and reload we can use the next command to handle it:  *dotnet watch run*

=== Using production mode

exception mesajlarını browserda kullanıcıdan gizlemek daha basit mesaj vermek için development mode yerine productin mod kullanılır. Bunu değiştirmek için: *properties-> launchSetting.json* 

image::..\DatingApp\course-images\img5.png[]

production olarak değiştirilir.

*Not:* Exception mesajları browsera değil consola log olarak yansır. Ordan exception mesajlarını detaylı olarak görebiliriz.
 

            

== Creating the firs Model and DataContext

we'll use entity fr. code first migration to store data

*create models -> Value*

----
namespace DatingApp.API.models
{
    public class Value
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }
}
----

*create data -> DataContext.cs*

----
using DatingApp.API.Models;
using Microsoft.EntityFrameworkCore;

namespace DatingApp.API.Data
{
    public class DataContext : DbContext //it is derived from Microsoft.EntityFrameworkCore. Need to include the library. 
    {
        public DataContext(DbContextOptions<DataContext> options) : base(options)
        {
        }

        public DbSet<Value> Values { get; set; } // Values represents table name.
    }
}


----

to use DbContext class we should add  *Microsoft.EntityFrameworkCore* library using nuget package manager.

*Finally* we export the class as service, to do that:
in *Startup.cs*

image::..\DatingApp\course-images\img6.png[]
to use sqlite we should add  *Microsoft.EntityFrameworkCore.Sqlite* library using nuget package manager.

*After adding libraries:*

image::..\DatingApp\course-images\img7.png[]

*Not:* By conventions we use title case for C# classes.

*to install dotnet entity framework tool:* via terminal type

=== Creating the Database using Entity Framework migrations

image::..\DatingApp\course-images\img8.png[]
image::..\DatingApp\course-images\img9.png[]

----
dotnet install --global dotnet-ef
dotnet-ef -h
dotnet ef migration -h
----

*after the next command:*
----
dotnet ef migrations add InitialCreate
----
*we get the error:*
----
Your startup project 'DatingApp.API' doesn't reference Microsoft.EntityFrameworkCore.Design. This package is required for the Entity Framework Core Tools to work. Ensure your startup project is correct, install the package, and try again.
----

to solve that we copy the package reference and installed it using nuget package manager: *Microsoft.EntityFrameworkCore.Design*

----
dotnet ef migrations add InitialCreate
----

image::..\DatingApp\course-images\img10.png[]


*the next command create the database:*

image::..\DatingApp\course-images\img11.png[]


*we'll open the datingapp.db using a tool(DB Browser for SQLite):*

image::..\DatingApp\course-images\img12.png[]

=== Retrieving data from the Database

inside Data -> DataContext.cs
----
before: 

  // GET api/values
        [HttpGet]
        public ActionResult<IEnumerable<string>> Get()
        {
            return new string[] { "value1", "value32" };
        }

after:

 public IActionResult GetValues()
        {
            var values = _context.Values.ToList();

            return Ok(values); //http 200 ok respond
        }

----



----
before:


after:

 // GET api/values/5
        [HttpGet("{id}")]
        public IActionResult GetValue(int id)
        {
            var value = _context.Values.FirstOrDefault(x => x.Id === id);

            return Ok(value);
        }


----

*to run project:*
----
dotnet watch run
----


*open postman:*

image::..\DatingApp\course-images\img15.png[]
image::..\DatingApp\course-images\img13.png[]
image::..\DatingApp\course-images\img14.png[]

=== Making our code asynchronous

*inside ValuesController:*

----
        // GET api/values
        [HttpGet]
        public async Task<IActionResult> GetValues()
        {
            var values = await _context.Values.ToListAsync();

            return Ok(values); //http 200 ok respond
        }

        // GET api/values/5
        [HttpGet("{id}")]
        public async Task<IActionResult> GetValue(int id)
        {
            var value = await _context.Values.FirstOrDefaultAsync(x => x.Id === id);

            return Ok(value);
        }
----


=== Creating the Angular application using AngularCLI

*https://cli.angular.io/*

----
inside our project:
npm install -g @angular/cli
ng new DatingApp-SPA
cd DatingApp-SPA
ng serve
----

image::..\DatingApp\course-images\img16.png[]

=== Adding VS Code extensions used in this course

. Angular snippets - john papa
. Angular files
. Angular language service
. Auto rename tag
. Bracket pair colorizer
. Debugger for chrome (we can debug our javascript code but this is really useful when we are in vscode)
. Material icon theme   
. Prettier - Code formatter
. TSLint
. angular2-switcher

=== 17. Making HTTP requests in Angular

Using right click in the src -> app folder create the new component named 'value'.

for automatically created the component references will be added to app.module.ts.

*to making http request in angular we should do next steps:*

image::Desktop\DatingApp\course-images\img17.png[]

*inside app.module.ts:*

image::Desktop\DatingApp\course-images\img18.png[]

*after that inside app.component.html file we call app-value selector to view of value.component.html*

image::Desktop\DatingApp\course-images\img19.png[]


*we should run the project inside two seperate terminal:*
----
ng serve

dotnet watch run
----

*if open browser and click inspect we get next error:*

Access to XMLHttpRequest at 'http://localhost:5000/api/values' from origin 'http://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.

*NOT:* it is probably for angular do not know the domain name api has.

=== Adding CORS support to the API

image::Desktop\DatingApp\course-images\img20.png[]
image::Desktop\DatingApp\course-images\img21.png[]

=> After doing them errors is gone.

image::Desktop\DatingApp\course-images\img22.png[]

=== 17. Displaying data from the API on the html page

image::Desktop\DatingApp\course-images\img23.png[]
image::Desktop\DatingApp\course-images\img24.png[]

=== 18. Adding Bootstrap and Font-Awesome to our Angular app

image::Desktop\DatingApp\course-images\img25.png[]

=== 19. Adding GIT for source control

*in the DatingApp folder:*
----
git init
----

*in the DatingApp.API folder add .gitignore file, add the gitignore following lines:*

----
.vscode
bin
obj
*.db
----

commit the change locally as 'Initial commit' on the left side bar.

*go to the github and create new repository and get the remote address and paste to terminal inside of project directory*

*to push local to remote:*


image::Desktop\DatingApp\course-images\img27.png[]


paste terminal inside your project directory

=== 20. Summary of Section 2

image::Desktop\DatingApp\course-images\img26.png[]

== Security

=== Introduction

image::Desktop\DatingApp\course-images\img28.png[]

=== Storing the passwords in the Database

image::Desktop\DatingApp\course-images\img29.png[]
image::Desktop\DatingApp\course-images\img30.png[]
image::Desktop\DatingApp\course-images\img31.png[]

---

*Hashing+salting* => Çok daha güçlü şifreler oluşturulur. Aynı password için bile çok farklı şifrelemeler oluşturulur. Bunu rasgele randomly oluşan salting sağlar.

---

=== Creating the User model

*inside model director => create User.cs file add the following props:*
----
namespace DatingApp.API.Models
{
    public class User
    {
        public int Id { get; set; } 
        public string Username { get; set; }
        public byte[] PasswordHash { get; set; }
        public byte[] PasswordSalt { get; set; }
    }
}
----

*and the go to DataContext.cs file and update the file:*

----
using DatingApp.API.Models;
using Microsoft.EntityFrameworkCore;

namespace DatingApp.API.Data
{
    public class DataContext : DbContext //it is derived from Microsoft.EntityFrameworkCore. Need to include the library. 
    {
        public DataContext(DbContextOptions<DataContext> options) : base(options)
        {
        }

        public DbSet<Value> Values { get; set; } // Values represents table name.
        
        public DbSet<User> Users { get; set; } //Users represent User table name
    }
}

----


*and then inside terminal:* 

---

dotnet ef migrations add AddedUserEntity

*after that:*

dotnet ef database update

---

*NOT:* If you look at the dbBrowser for sqlite you  can see the user table in there.

=== The repository pattern

image::Desktop\DatingApp\course-images\img32.png[]
image::Desktop\DatingApp\course-images\img33.png[]


=== Creating an Interface for the Repository

*inside Data folder create new interface named IAuthRepository, and then add following line inside it*:

----
using System.Threading.Tasks;
using DatingApp.API.Models;

namespace DatingApp.API.Data
{
    public interface IAuthRepository
    {
         Task<User> Register(User user, string password);
         Task<User> Login (string username, string password);
         Task<bool> UserExists(string username);
    }
}
----

=== Creating the concrete Auth Repository and Register Method

----
using System;
using System.Threading.Tasks;
using DatingApp.API.Models;

namespace DatingApp.API.Data
{
    public class AuthRepository : IAuthRepository
    {
        private readonly DataContext _context;
        public AuthRepository(DataContext context) //to inject DataContext to this class.
        {
            _context = context;
        }
        public Task<User> Login(string username, string password)
        {
            throw new System.NotImplementedException();
        }

        public async Task<User> Register(User user, string password)
        {
            byte[] passwordHash, passwordSalt;

            CreatePasswordHash(password, out passwordHash, out passwordSalt);

            user.PasswordHash = passwordHash;
            user.PasswordSalt = passwordSalt;

            await _context.Users.AddAsync(user);
            await _context.SaveChangesAsync();

            return user;

        }

        private void CreatePasswordHash(string password, out byte[] passwordHash, out byte[] passwordSalt)
        {
            using (var hmac = new System.Security.Cryptography.HMACSHA512())
            {
                passwordSalt = hmac.Key;
                passwordHash = hmac.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password));
            }

        }

        public Task<bool> UserExists(string username)
        {
            throw new System.NotImplementedException();
        }
    }
}
----

image::Desktop\DatingApp\course-images\img34.png[]


=== 7. Creating the Login repository method

image::Desktop\DatingApp\course-images\img35.png[]
image::Desktop\DatingApp\course-images\img36.png[]


=== 8. Registering services in the Startup class

---

Şimdi oluşturduğumuz IAuthRepository ve AuthRepository classlarının application ile haberleşmesi için bunu startup classında service olarak tanımlamalıyız. Bu sayede bu repositoryleri classımıza enjekte etmiş olur.

---

image::Desktop\DatingApp\course-images\img37.png[]

=== 9. Creating the Register method in our Auth Controller

we Create new Controller inside Controllers named AuthController. And then filled the controller.

----
using System.Threading.Tasks;
using DatingApp.API.Data;
using DatingApp.API.Models;
using Microsoft.AspNetCore.Mvc;

namespace DatingApp.API.Controllers
{
    [Route("api/[controller]")]  //means  ->  /api/Auth routes to AuthController
    [ApiController]   //attribute
    public class AuthController : ControllerBase //A base class for an MVC controller without view, we use angular for view implementation
    {
        private readonly AuthRepository _repo;
        public AuthController(AuthRepository repo)
        {
            _repo = repo;
        }


        [HttpPost("register")]
        //we will refactor parameter type later on. Because the parameter will come in json format.
        public async Task<IActionResult> Register(string username, string password) 
        {
            username = username.ToLower();


            if(await _repo.UserExists(username)) 
                return BadRequest("Username already exists"); // to use this method we have to implemet controllerbase class to this controller.
            //for Register method get user object. we create user object.
            var userToCreate = new User{
                Username = username
            };

            var createdUser = await _repo.Register(userToCreate, password);
            
            return StatusCode(201); //we will refactor this later on.

        }    


    }
}
----

=== 10. Using DTOs (Data Transfer Objects)

inside DatingApp.API create  Dtos folder and then inside it create UserForRegisterDto:

----
namespace DatingApp.API.Dtos
{
    public class UserForRegisterDto
    {
        public string Username { get; set; }
        public string Password { get; set; }
    }
}
----

Bu proplar register için gelen requestin değerlerini tutucak.

Debug yaparsak:

image::Desktop\DatingApp\course-images\img39.png[]


=== Token Authentication

image::Desktop\DatingApp\course-images\img40.png[]
image::Desktop\DatingApp\course-images\img41.png[]
image::Desktop\DatingApp\course-images\img42.png[]
image::Desktop\DatingApp\course-images\img43.png[]

=== Creating the Login method in the API

*By NuGet package manager, Install:* 

. "Microsoft.IdentityModel.Tokens" -> latest stabel version
. "System.IdentityModel.Tokens.Jwt"

inside AuthController -> create the login method.

----
 [HttpPost("login")]

        public async Task<IActionResult> Login(UserForLoginDto userForLoginDto)
        {
            var userFromRepo = await _repo.Login(userForLoginDto.Username.ToLower(), userForLoginDto.Password);

            if (userFromRepo == null)  //ıf the user dosent exist in db it return null.
                return Unauthorized();


            var claims = new[] {
                new Claim(ClaimTypes.NameIdentifier, userFromRepo.Id.ToString()),  //token string old. ToString() yaptık.
                new Claim(ClaimTypes.Name, userFromRepo.Username)
            };

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config.GetSection("AppSettings:Token").Value)); //we store the key in the AppSetting.Json file
                                                                                                                    //.Value is used to get the value of this token
            //encrypting the key using hashing algorithm                                                                  
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha512Signature);

            var tokenDescriptor = new SecurityTokenDescriptor{
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.Now.AddDays(1), //expire date is a day. It is just for training course purposes.
                SigningCredentials = creds
            };

            var tokenHandler = new JwtSecurityTokenHandler();

            var token = tokenHandler.CreateToken(tokenDescriptor);

            return Ok(new {
                token = tokenHandler.WriteToken(token)
            });
        }
----


*add the token key inside AppSettings.json file *

----
{
  "AppSettings":{
    "Token": "super secret key" 
  },
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=datingapp.db"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}




----

image::Desktop\DatingApp\course-images\img44.png[]   


=== Using the Authentication middleware

Bu katmanla valueController Authenticationdan haberdar olacak ve herhangi bir veri isteğinden veya requestte dtabase gidip kimlik doğrulama yapmayacak.

*Öncelikle bazı paketleri indirmemiz gerekir NuGet package managerdan:*

. Microsoft.AspNetCore.Authentication.JwtBearer -> Version="3.1.3"

image::Desktop\DatingApp\course-images\img45.png[]

[Authorize] atributun bu yetkilendirmeyi anlaması için startup.cs classında bunu servis olarak eklememiz gereekir.(We should add authentication as a service)(We have to say AspNet core what type authentication we use)

image::Desktop\DatingApp\course-images\img47.png[]
image::Desktop\DatingApp\course-images\img46.png[]

*Open postman and test the changes:*

to get single value:

image::Desktop\DatingApp\course-images\img48.png[]

to get all the values:

image::Desktop\DatingApp\course-images\img49.png[]

*to get all the values we must be authorized. to do that we shoul login and then get the token and past the token in the header section of the get request:*

image::Desktop\DatingApp\course-images\img52.png[]

image::Desktop\DatingApp\course-images\img50.png[]
image::Desktop\DatingApp\course-images\img51.png[]

=== Safe storage of secrets

appsettings.json da tokenla alakalı hassas bilgiler olduğu için bu dosyayı github gibi halka açık bbir platforma göndermek iyi değildir. Bu yüzden bu dosyayı untracked yapmalıyız.

image::Desktop\DatingApp\course-images\img53.png[]

----
$ git rm appsettings.json --cached
----

Aslında tokena ait key'i production modda appsettings.json da değil bazı işlemlerle başka bir yerde gizleyerek tutarız. Buna ilerleyen bölümlerde bakıcaz.

 
== Bölüm 4:Client side login and register

=== Introduction

image::Desktop\DatingApp\course-images\img54.png[]

=== Creating the Navigation and Login form

https://getbootstrap.com/docs/4.1/examples/jumbotron/?#

. inspect -> copy the element
. create a new component named nav
. inside the html page of nav paste the element info    

*NOT:* Bu modülün açıklamalarını angularda editör üzerinde yaptık. Kod satırları ile anlayabilirim.


== Bölüm 5:Error Handling

=== Handling exceptions in the API

*500 internal error:* server errordur. angular tarafıyla  ilgisi yoktur. api tarafından oluşur.

=== Setting up the Global exception handler in the API

*NOT:* _Global exception Handling sayesinde try-catchle blokları ile biz uğraşmadan ASP .NET CORE bizim yerimize hataları handle eder._

AuthController classının login metodunda tanımladığımız try-catch bloklarını kaldırırız öncelikle.

image::Desktop\DatingApp\course-images\img55.png[]
image::Desktop\DatingApp\course-images\img56.png[]

Global exception handlera cause header eklemek için ekstra bir metoda ihtiyacımız var. Bu yüzden Helper folderı oluşturup Extensions classını ve AddApplicationError metodlarını static olarak oluştururuz.

----
using Microsoft.AspNetCore.Http;

namespace DatingApp.API.Helpers
{
    public static class Extensions //Extension metodları içerecek class. Nesne örneğini oluşturmamak için static olarak tanımladık.
    {
        public static void AddApplicationError(this HttpResponse response, string message){ //to override http response : this HttpResponse response 
            //reponse(global exception handler tarafından gönderilen response) a yeni header eklemek istediğimiz için:
            response.Headers.Add("Application-Error", message);
            response.Headers.Add("Access-Control-Expose-Headers","Application-Error");
            response.Headers.Add("Access-Control-Allow-Origin","*"); //*: is a wildcard(joker) = yani tüm originlere izin ver demek.

        }
    }
}
----

image::Desktop\DatingApp\course-images\img57.png[]
----
$ dotnet run
----

*Postmande istek yapalım:*

image::Desktop\DatingApp\course-images\img58.png[]
image::Desktop\DatingApp\course-images\img59.png[]


*NOT:* Server tarafından gönderilen bu cause headerler sayesinde kullanıcı hatayla ilgili bilgilendirilmiş olunur.

=== 4. Handling errors in Angular

. *services klasörüne error.interceptor.ts adında boş bir file oluşturup aşağıdaki gibi şablonu oluştururuz.*

Bu class yardımı ile apidan gelen hataları istediğimiz gibi filtreler angular tarafına, browser tarafına istediğimiz yalınlıkla ve uygunlukta göndeririz.

----
import {
  HttpErrorResponse,
  HttpEvent,
  HttpHandler,
  HttpInterceptor,
  HttpRequest,
  HTTP_INTERCEPTORS,
} from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

//Bu bir servis classı olmamasına rağmen servis folderının içerisinde yazmamızın sebebi bu koyacak doğru yerin burası olması.

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  //HttpInterceptor Api tarafından gelen hataları tanıyacak ve yakalayacak
  intercept(
    req: HttpRequest<any>,
    next: HttpHandler
  ): Observable<HttpEvent<any>> {
    //throw new Error('Method not implemented.'); 'ı sildik.
    return next.handle(req).pipe(
      catchError((error) => {
        if (error.status === 401) {
          return throwError(error.statusText); //angular componente fırlatılır.
        }
        if (error instanceof HttpErrorResponse) {
          //this condition takes care of 500 error(internal error)
          const applicationError = error.headers.get('Application-Error'); //Application-Error isimli headera sahip internal server errorı çeker.
          if (applicationError) {
            return throwError(applicationError);
          }

          const serverError = error.error;
          let modalStateErrors = ''; //email, password dosent provide requirements örn: parola 3 haneden buyuk olmalı.
          if (serverError.errors && typeof serverError.errors === 'object') {
            //serverError.errors obje ise loop ile içerisini gezip elemanları kullancaz
            for (const key in serverError.errors) {
              if (serverError.errors[key]) {
                modalStateErrors += serverError.errors[key] + '\n';
              }
            }
          }
          return throwError(modalStateErrors || serverError || 'server error'); //modalStateError boş ise serverErroru gönderir. burda serverError===error.error 'a eşittir. o da 'username already exists' 'e denk gelir diyebiliriz.
          //Hiçbiri değilse 'server error' mesajlı exception atar. Sonradan gelip bu errorun ne olduğunu anlamaya çalışırız.
          //serverError=error.error -> username already exists. : Sadece string mesaj olan error.
        }
      })
    );
  }
}

export const ErrorInterceptorProvider = {
  provide: HTTP_INTERCEPTORS,
  useClass: ErrorInterceptor,
  multi: true, // HTTP_INTERCEPTORS can have many interceptor.
};

----

image::Desktop\DatingApp\course-images\img60.png[]


== Adding 3rd party components to our app

=== Wrapping 3rd party libraries as an Angular service

*_alertifyjs_:* Kullanıcıya notification vermek için kullanılır.

.go to the client app(DatingApp-SPA) inside terminal and run the next command.

----
$ npm install alertifyjs
----


.alertifyjs in referanslarını style.css classına global olarak ekleriz.


image::Desktop\DatingApp\course-images\img61.png[]

.alertifyı diğer componentlerin ortak bir noktadan kullanabilmeleri için servis olarak oluşturuyoruz.

----
import { Injectable } from '@angular/core';
import * as alertify from 'alertifyjs';

@Injectable({
  providedIn: 'root'
})
export class AlertifyService {

constructor() { }

  confirm(message: string, okCallBack: () => any) { //dönüş tipi herhangi bir tip olabileck fonksiyonu parametre olarak böyle tanımlarız.
    alertify.confirm(message, (e:any)=>{
      if(e){
        okCallBack();
      }else{}
    });
  }

  success(message:string){
    alertify.success(message);
  }

  
  error(message:string){
    alertify.error(message);
  }

  
  warning(message:string){
    alertify.warning(message);
  }

  
  message(message:string){
    alertify.message(message);
  }
}
----

*bu servisi nav ve register componentin kullanabilmesi için bu servisleri enjekte ederler.*

image::Desktop\DatingApp\course-images\img62.png[]

=== Using the Angular JWT library to improve token handling

. type google 'auth0 angular jwt'
. https://github.com/auth0/angular2-jwt
. And then go back terminal window and run 'npm install @auth0/angular-jwt' command to install this package to SPA 
----
$ npm install @auth0/angular-jwt
----

Kullanıcının login olup olmadığını kontrol eden metodu daha önce nav componentte yazmıştık.

*before:*

----

  loggedIn(){
    const token = localStorage.getItem('token'); //local storagedan keyi token olan tokenı getirir.
    return !!token; // if token empty ise false, dolu ise true döndürür.
  }
----

Ama bu metodu burada yazmak mantıklı değil çünkü bu metodu diğer componentler de yeri geldiği zaman kullanacak. Bu metodu kullanacak componentlerin nav componenti import etmeleri gerekecek. Componentlerin görevi bu değildir. Bu servislerin görevidir. Daha önce oluşturduğumuz authservice servisine bu metodu oluştururuz. 

*after:*

image::Desktop\DatingApp\course-images\img63.png[]


Bu servisi nav componente daha inject etmiştik. metoda bağlayalım

----
  loggedIn(){
    // const token = localStorage.getItem('token'); //local storagedan keyi token olan tokenı getirir.
    // return !!token; // if token empty ise false, dolu ise true döndürür.
    return this.authService.loggedIn();
  }

----

=== Using the Angular JWT library to decode tokens

---

Bu bölümde jwt kütüphanesi yardımıyla elde ettiğimiz tokenı decode edip kullanıcı adını çekip sağ üstte login olduktan sonraa *welcome kullanıcıAdı* şeklinde görüntüleyeceğiz.

---

image::Desktop\DatingApp\course-images\img64.png[]
image::Desktop\DatingApp\course-images\img65.png[]
image::Desktop\DatingApp\course-images\img66.png[]

---

Sayfayı yenilediğimiz zaman kullanıcı adı görülmeyecek çünkü bu kullanıcı adını sadece login olduğumuz zaman çekiyoduk. Bu yüzden bunu merkezi bir yerde de yapmalıyız. Her app load olduğu zaman kullanıcı adını çekmeli local storagedan. Bu yer *app component olmalı*

---

*Before*

image::Desktop\DatingApp\course-images\img67.png[]

*After*

inside app.component.ts:

----
import { Component, OnInit } from '@angular/core';
import { JwtHelperService } from '@auth0/angular-jwt';
import { AuthService } from './_services/auth.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})

//Bu class angular cli tarafından oluşturulduğundan şablon tamamlanmamıştır. oninit, constructor ve gerekli kütüphaneleri biz ekleyeceğiz. tokendan username'i çekmek için.

export class AppComponent implements OnInit {
  jwtHelper = new JwtHelperService();
  constructor(private authService: AuthService) {
    
  }
  ngOnInit(){
    const token = localStorage.getItem('token');
    if(token){
      this.authService.decodedToken = this.jwtHelper.decodeToken(token);
    }
    
  }

}

----

---

app.component.ts' de yapılan değişikliklerden sonra artık sayfayı reload yaptığımız zaman da hata almadık.

---

=== Adding Ngx Bootstrap to power our Bootstrap components

 . https://valor-software.com/ngx-bootstrap/#/

*NOT:* angularjs ile çalıştığımız zaman Ngx Bootstrap ile elde edeceğimiz fonksiyonaliteler orda default olarak mevcut olur. Fakat angularjs jquerye bağımlıdır. Angular ile çalışırken jquery ile çalışmak mantıklı gelmiyor. bu yüzden kurs boyunca pure angular gidicez. Burda Ngx Bootsrap işimizi oldukça iyi görür.

----
$ npm install ngx-bootstrap --save
----

*NOT:* npm install kullandığımız için app.module.ts import bolumune BrowserAnimationsModule' u eklememiz gerektiğini söyledi Neil. Ekledik.

image::Desktop\DatingApp\course-images\img68.png[]
image::Desktop\DatingApp\course-images\img69.png[]
image::Desktop\DatingApp\course-images\img70.png[]

=== Bringing some color to our app with a theme from Bootswatch

 . https://bootswatch.com/ : Free themes for Bootstrap

 . install the same version of the bootstrap
 
----
 $ npm install bootswatch@version
----

.Bootswatch kütüphanesini hemen bootsrap kütüphanesinn altına koyarız. Aslında suan bootstrap kütüphanesini kaldırabiliriz de.
image::Desktop\DatingApp\course-images\img71.png[]

.primary yapmamızın sebebi dark olursa turuncuyu mora çeviriyordu.
image::Desktop\DatingApp\course-images\img72.png[]

== Routing in Angular

===  Setting up routing in Angular

Bu bölümde oluşturduğumuz yeni componentler arasında routing işlemini göreceğiz.

öncelikle app folder içerisinde routes.ts file oluşturup aşağıdaki dolduralım.

.Bunu kullanabilmek için app.module.ts'e import etmemiz gerekir.

image::Desktop\DatingApp\course-images\img73.png[]

----
RouterModule.forRoot(appRoutes)
----

import kısmına yukardaki satırı ekleyip ilgili file'da yukarıya import ederiz .

=== Protecting our routes with a route guard

---

Yetkisi olmayan kullanıcının url' i değiştirerek farklı routelara girmesini engellemek için *route guard* kullanılır.

---

. app -> _guard folder oluşturulur.
. cd src/app/_guards
. angular cli ile aşağıdaki komut çalıştırılır.
. choose canActivate interface

----
$ ng g guard auth --skipTests
----

--skipTests : test istemiyoruz

---

Yukarıdaki çalıştırılan komutla auth.guard.ts oluşturulmuş olur. Default şablonda çok fazla şey vardır. Biz kendi ihtiyaçlarımıza göre şablonu düzelltik.

---

*auth.guard.ts :*


----
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { AlertifyService } from '../_services/alertify.service';
import { AuthService } from '../_services/auth.service';

@Injectable({
  providedIn: 'root',
})
export class AuthGuard implements CanActivate {
  constructor(
    private authService: AuthService,
    private router: Router,
    private alertify: AlertifyService
  ) {}

  //Sadece true olduğunda bu route'u aktif et.
  canActivate(): boolean {
    if(this.authService.loggedIn()){
      return true;
    }

    this.alertify.error('You shall not pass!!!');
    this.router.navigate(['/home']);
    return false;
  }
}

----

---

Şimdi routes.ts de oluşturduğumuz path-component çiftlerinden hangisi korumak istiyosak canActivate[AuthGuard] ile koruruz.

---

*routes.ts:*

----
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { ListsComponent } from './lists/lists.component';
import { MemberListComponent } from './member-list/member-list.component';
import { MessagesComponent } from './messages/messages.component';
import { AuthGuard } from './_guards/auth.guard';

export const appRoutes : Routes = [
    {path: 'home', component: HomeComponent}, //path-component cifti yazılır. Order is important. Wildcard başta olsa hep aynı domaine gider mesela.
    {path: 'members', component: MemberListComponent, canActivate: [AuthGuard]},
    {path: 'messages', component: MessagesComponent},
    {path: 'lists', component: ListsComponent},
    {path: '**', redirectTo: 'home', pathMatch:'full'}, //joker: yukarıdakilerden herhangi biri ile eşleşmesse buraya yönledirilir. Angular first match mantığına göre çalışır. Hangi pathle eşleşirse oraya gider ilk.
];


----

===  Protecting multiple routes with a single route guard using dummy routes


Buradaki amaç her ayrı route için *canActivate: [AuthGuard]* kullanmak yerine bunlar için temsili bir parent root oluşturulup bunları merkezi bir yerden kontrol etmektir.

